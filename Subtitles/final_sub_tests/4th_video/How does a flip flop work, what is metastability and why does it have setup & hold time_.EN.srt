1
00:00:00,000 --> 00:00:03,500
[Music]

2
00:00:03,500 --> 00:00:07,400
So I finally finished my flip-flop
video, took a lot longer than I thought,

3
00:00:07,400 --> 00:00:11,900
and that's because every time I try to record
the video, I get to this point and I realize

4
00:00:11,900 --> 00:00:16,100
I still can't explain this bit, and I'd
have to go a little bit deeper, dig down
a bit,

5
00:00:16,100 --> 00:00:20,400
and finally get the answer. And it's
been like that for quite a few days now.

6
00:00:20,400 --> 00:00:23,700
I also want to say thanks to everyone on
the course, because it's your support

7
00:00:23,700 --> 00:00:27,900
that lets me make these kinds of
deep-die videos to satisfy my curiosity.

8
00:00:27,900 --> 00:00:31,600
So let's start off by looking at what's
going to be covered in this video.

9
00:00:31,600 --> 00:00:34,588
So small text means we're not
going to spend too much time, and

10
00:00:34,612 --> 00:00:37,600
big text is what the bulk of the
video is going to be spent on.

11
00:00:37,600 --> 00:00:42,800
To give it a bit of a contextual overview, we're going
to look at Combinatory versus sequential circuits,

12
00:00:42,800 --> 00:00:47,100
moving on to latches and flip-flops, and then the
majority of the time we're going to be looking at

13
00:00:47,100 --> 00:00:50,800
how a flip-flop really works, why does
it set up a whole time come from,

14
00:00:50,800 --> 00:00:54,000
what does a set up and hold violation
mean, and metastability.

15
00:00:54,000 --> 00:00:59,900
So really maybe the first question is, why do we need flip-flops
in the first place? Why do we need sequential circuits?

16
00:00:59,900 --> 00:01:04,400
So when we're designing digital logic,
whether it's for an FPGA or an ASIC,

17
00:01:04,400 --> 00:01:08,300
the part of the circuit that is doing
the work, like an adder or a multiplier,

18
00:01:08,300 --> 00:01:15,400
that's all built out of combinatorial logic, things like,
AND gates, OR gates, XORs, NOTs, these kinds of things.

19
00:01:15,400 --> 00:01:18,500
And we have this big pile of
logic, we put the numbers in,

20
00:01:18,500 --> 00:01:26,000
and then a short while later, as the data propagates through
that collection of cells, we get the answer out of the end.

21
00:01:26,000 --> 00:01:29,200
Now imagine we're implementing a
filter, and we want to take that output,

22
00:01:29,200 --> 00:01:32,700
and then run it back through the
multiplier a certain number of times.

23
00:01:32,700 --> 00:01:35,600
If we just take the output
and route it back to the input,

24
00:01:35,600 --> 00:01:39,600
we're going to get a weird condition, a race
condition, where the data is flowing round and round,

25
00:01:39,600 --> 00:01:42,200
and we lose control of what's happening.

26
00:01:42,200 --> 00:01:45,700
So what we've got to do is we've
got to catch that data as it comes out,

27
00:01:45,700 --> 00:01:49,400
wait, and put it back in at the
beginning at the correct time,

28
00:01:49,400 --> 00:01:51,900
and usually that's
coordinated with a clock.

29
00:01:51,900 --> 00:01:56,900
So the types of circuits that can catch
the data and hold it until a clock comes

30
00:01:56,900 --> 00:02:01,400
are called latches or flip-flops, and
they're used for sequencing data flow.

31
00:02:01,400 --> 00:02:04,500
So one thing to bear in
mind is this is a huge topic.

32
00:02:04,500 --> 00:02:09,000
In my reference book, the Weste Harris
book, it's a really big chunk of the book,

33
00:02:09,000 --> 00:02:11,200
Chapter 7, all about sequencing,

34
00:02:11,200 --> 00:02:16,400
and this is really just focusing on a single
type of flip-flop and looking at how it works.

35
00:02:16,400 --> 00:02:19,000
So before we can make a
flip-flop, we need to make a latch.

36
00:02:19,000 --> 00:02:20,500
So what is a latch?

37
00:02:20,500 --> 00:02:24,900
Well, the simplest type of latch is just
a MOSFET with the D data coming in

38
00:02:24,900 --> 00:02:27,800
and the Q data out going out,

39
00:02:27,800 --> 00:02:31,200
and this allows the data to flow through
when the clock is high,

40
00:02:31,200 --> 00:02:33,400
because it's an N channel MOSFET.

41
00:02:33,400 --> 00:02:38,300
But it's got a lot of problems. It's not
immune to noise on the input.

42
00:02:38,300 --> 00:02:44,500
It's a dynamic circuit, so the output is only
there because of capacitance on the wires.

43
00:02:44,500 --> 00:02:50,100
So as time goes by, this one
value will degrade down to a zero.

44
00:02:50,100 --> 00:02:54,100
We can improve the immunity
by having a transmission gate,

45
00:02:54,100 --> 00:02:57,400
which is a P type and
an N type in parallel,

46
00:02:57,400 --> 00:03:01,700
so it allows a 0 or a 1 through as
long as the clock is set correctly.

47
00:03:01,700 --> 00:03:05,400
And then we can put a buffer at the end,

48
00:03:05,400 --> 00:03:09,000
so that it can drive a bit harder,
have a bit more capacitance,

49
00:03:09,000 --> 00:03:11,800
and store that dynamic value for longer.

50
00:03:11,800 --> 00:03:15,500
And then we can build up to a latch
like this that has a feedback circuit

51
00:03:15,500 --> 00:03:20,800
where the output of one inverter
drives the input of a tri-state inverter

52
00:03:20,800 --> 00:03:23,800
and that comes back round
and reinforces the circuit,

53
00:03:23,800 --> 00:03:28,000
and we can disconnect the
input with this transmission gate.

54
00:03:28,000 --> 00:03:30,800
So if we take a quick look at this,

55
00:03:30,800 --> 00:03:34,400
we've got this enable here with the
clock and the knock lock,

56
00:03:34,400 --> 00:03:40,800
and that basically turns on or off the output
of this inverter that is on the outside.

57
00:03:40,800 --> 00:03:44,200
So if we've got a 1 coming
in here, this is going to be off.

58
00:03:44,200 --> 00:03:46,600
This is going to be on,
it's going to pull it down,

59
00:03:46,600 --> 00:03:48,700
so the one is going to
get turned into a 0.

60
00:03:48,700 --> 00:03:52,100
But only if these two
are also set correctly.

61
00:03:52,100 --> 00:03:56,300
So by setting these on or off,
we can make this turn on or off.

62
00:03:56,300 --> 00:03:58,700
That's what a tri-state inverter.

63
00:03:58,700 --> 00:04:02,700
And you'll see as we move on in the video
that we're going to use a pair of latches

64
00:04:02,700 --> 00:04:05,400
to build a flip-flop.

65
00:04:05,400 --> 00:04:08,300
So now we get on to
what flip-flops actually are.

66
00:04:08,300 --> 00:04:11,900
They're a way of sampling a
bit of data as the clock comes in

67
00:04:11,900 --> 00:04:15,400
and then holding it steady, no
matter what the D input is doing,

68
00:04:15,400 --> 00:04:18,400
and wait until the
next rising clock edge.

69
00:04:18,400 --> 00:04:20,100
And there's a wide variety of flip-flops.

70
00:04:20,100 --> 00:04:23,300
So there's an interesting paper here
that was recommended by a friend,

71
00:04:23,300 --> 00:04:27,100
and we've got different types like
inverting outputs with reset,

72
00:04:27,100 --> 00:04:29,500
resampling on the rising or falling edge,

73
00:04:29,500 --> 00:04:33,700
different setup and hold times,
resulting in different aperture sizes,

74
00:04:33,700 --> 00:04:36,400
power consumption, and
different things like this.

75
00:04:36,400 --> 00:04:42,100
So this paper does quite a good job of comparing a
whole different type of flip-flops against each other

76
00:04:42,100 --> 00:04:45,800
and then choosing the most
recommended one for the best immunity,

77
00:04:45,800 --> 00:04:50,000
the best immunity to raise
conditions that least power consumed,

78
00:04:50,000 --> 00:04:51,400
these kinds of things.

79
00:04:51,400 --> 00:04:54,000
So what would an ideal flip-flop be like?

80
00:04:54,000 --> 00:04:57,300
Remember we're going to be
using these to sequence data.

81
00:04:57,300 --> 00:05:01,700
So the more time we spend
capturing and holding onto that data,

82
00:05:01,700 --> 00:05:04,300
the less time we've
got to actually do work.

83
00:05:04,300 --> 00:05:07,500
So an ideal flip-flop
should sample immediately.

84
00:05:07,500 --> 00:05:10,200
The output should
immediately flow to the output,

85
00:05:10,200 --> 00:05:13,500
and it should take hardly
any time to do the sampling.

86
00:05:13,500 --> 00:05:15,400
There should be no
ambiguity on the output.

87
00:05:15,400 --> 00:05:17,500
It should either always be 0 or 1,

88
00:05:17,500 --> 00:05:20,100
and it should always sample
exactly on the clock edge,

89
00:05:20,100 --> 00:05:22,100
or maybe we can move it
forwards and backwards,

90
00:05:22,100 --> 00:05:24,100
but it's a very predictable time.

91
00:05:24,100 --> 00:05:27,100
So I've got a background in
engineering and science communication

92
00:05:27,100 --> 00:05:31,500
and my engineering background is one of the
things that makes me love a practical example.

93
00:05:31,500 --> 00:05:35,900
And that's one reason why I think this
Sky130 open source PDK is so good

94
00:05:35,900 --> 00:05:40,100
because it allows me to share this kind
of information with real-world examples

95
00:05:40,100 --> 00:05:43,300
without having to sign,
NDAs, or ask for permission.

96
00:05:43,300 --> 00:05:47,700
So I'm going to use some
Verilog to describe some hardware,

97
00:05:47,700 --> 00:05:50,400
because that's what Verilog is,
hardware description language,

98
00:05:50,400 --> 00:05:53,400
and I'm going to say on
the positive edge of a clock,

99
00:05:53,400 --> 00:05:55,600
sample the D and put it into Q,

100
00:05:55,600 --> 00:05:56,900
and Q should be a register.

101
00:05:56,900 --> 00:05:58,900
You should remember what it is.

102
00:05:58,900 --> 00:06:03,700
And when I run that through
OpenLane, I get a D type flip-flop.

103
00:06:03,700 --> 00:06:07,400
And when I take my GDS
and I load that up in K layout,

104
00:06:07,400 --> 00:06:10,700
I get this, which is a fairly
complicated standard cell.

105
00:06:10,700 --> 00:06:12,700
It's quite a big one.

106
00:06:12,700 --> 00:06:17,900
Every time polysilicon overlaps
some of the P type or N type,

107
00:06:17,900 --> 00:06:21,600
that's the kind of cyan or
gray there, we get a MOSFET.

108
00:06:21,600 --> 00:06:24,000
So we've got 26 different MOSFETs here.

109
00:06:24,000 --> 00:06:25,900
A range in a fairly complicated pattern,

110
00:06:25,900 --> 00:06:28,500
and that builds up half-flop.

111
00:06:28,500 --> 00:06:31,000
So when I want to really
understand something,

112
00:06:31,000 --> 00:06:34,800
especially like a standard cell, I like
to try and do a manual circuit extraction

113
00:06:34,800 --> 00:06:38,400
to pull out all those connections
onto a piece of paper.

114
00:06:38,400 --> 00:06:40,000
And this took me quite a long time,

115
00:06:40,000 --> 00:06:41,600
much longer than the MUX example,

116
00:06:41,600 --> 00:06:43,800
but I did a few videos back.

117
00:06:43,800 --> 00:06:45,600
And you can see, actually here,

118
00:06:45,600 --> 00:06:49,600
I thought I'd done where I had an
inverter followed by transmission gates.

119
00:06:49,600 --> 00:06:52,100
But actually, it's a tri-state inverter,

120
00:06:52,100 --> 00:06:55,000
which is a slightly different structure.

121
00:06:55,000 --> 00:06:57,000
So this is the final extraction,

122
00:06:57,000 --> 00:06:59,500
which I'm fairly sure is correct.

123
00:06:59,500 --> 00:07:02,700
And then I got some help from Proppy on
the course

124
00:07:02,700 --> 00:07:08,200
to make a nice neat schematic using
Schemdraw python library

125
00:07:08,200 --> 00:07:11,300
and Maximo did this cool render.

126
00:07:11,300 --> 00:07:15,300
So we've got the positive supply, the
negative supply,

127
00:07:15,300 --> 00:07:20,100
and we've got the D input inverter here.

128
00:07:20,100 --> 00:07:22,400
And then for our clock, we're taking a
clock in

129
00:07:22,400 --> 00:07:27,500
and then generating an inverted and an
inverted-inverted clock.

130
00:07:27,500 --> 00:07:30,400
So that's happening here and being
distributed

131
00:07:30,400 --> 00:07:34,600
to the transmission gates here.

132
00:07:34,600 --> 00:07:38,700
And over this side, we're looking at the
output,

133
00:07:38,700 --> 00:07:41,400
which is a double-ganged inverter.

134
00:07:41,400 --> 00:07:43,300
So we've got a two-time striped strength.

135
00:07:43,300 --> 00:07:45,100
So how does a flip-flop flop?

136
00:07:45,100 --> 00:07:47,800
Well, let's take a look at
the circuit in a bit more detail.

137
00:07:47,800 --> 00:07:51,600
I've taken this top circuit
and then worked out

138
00:07:51,600 --> 00:07:53,500
what happens for the transmission gates

139
00:07:53,500 --> 00:07:56,200
when the clock is low or
high and then kind of drawn out

140
00:07:56,200 --> 00:07:58,100
these two separate circuits.

141
00:07:58,100 --> 00:08:00,300
So we start off when the clock is low.

142
00:08:00,300 --> 00:08:02,300
The output is steady and it's isolated

143
00:08:02,300 --> 00:08:05,500
because you've got this
one bit of data, a 0 or 1,

144
00:08:05,500 --> 00:08:07,600
reinforcing itself,
this static memory

145
00:08:07,600 --> 00:08:10,100
being driven output to Q.

146
00:08:10,100 --> 00:08:12,600
And the input is kind
of sampling all the time.

147
00:08:12,600 --> 00:08:16,500
Whatever is on D is inverted
and then is charging up A.

148
00:08:16,500 --> 00:08:18,700
And at the moment
when the clock goes high,

149
00:08:18,700 --> 00:08:21,100
this transmission gate opens and the one

150
00:08:21,100 --> 00:08:25,300
that creates the first
latch inverter closes.

151
00:08:25,300 --> 00:08:28,100
And so whatever was on A
is now going to get reinforced

152
00:08:28,100 --> 00:08:30,800
in this loop, the input's
going to get ignored

153
00:08:30,800 --> 00:08:33,200
and the output is going
to go straight out to Q.

154
00:08:33,200 --> 00:08:35,200
So we have this race condition

155
00:08:35,200 --> 00:08:37,700
between the data coming in and the clock.

156
00:08:37,700 --> 00:08:41,000
If the data is changing at
the moment when we sample,

157
00:08:41,000 --> 00:08:43,800
we could have something
that isn't exactly a 0 or a 1

158
00:08:43,800 --> 00:08:46,500
on here and that can cause problems.

159
00:08:46,500 --> 00:08:49,100
So this is what leads
us onto a metastability

160
00:08:49,100 --> 00:08:51,200
So we have our zero state, a zero volts

161
00:08:51,200 --> 00:08:53,000
and our one state, a 1.8 volts.

162
00:08:53,000 --> 00:08:54,400
And those are both stable.

163
00:08:54,400 --> 00:08:57,100
It takes work to change those values

164
00:08:57,100 --> 00:09:00,300
and get them to over the hill
and change to the other one.

165
00:09:00,300 --> 00:09:04,400
But let's say that the
D input was changing

166
00:09:04,400 --> 00:09:08,300
and it was exactly 0.9 volts at
the moment the clock went high.

167
00:09:08,300 --> 00:09:10,900
Then we start off
right at this top position,

168
00:09:10,900 --> 00:09:12,900
which is a meta-stable place.

169
00:09:12,900 --> 00:09:14,400
It doesn't really want to stay there.

170
00:09:14,400 --> 00:09:16,300
It can move off from
one side to the other.

171
00:09:16,300 --> 00:09:19,300
But it will stay there for
a lot longer than normal.

172
00:09:19,300 --> 00:09:21,100
Then some fluctuation in the power supply

173
00:09:21,100 --> 00:09:22,600
or something like that changes

174
00:09:22,600 --> 00:09:26,000
and we flip into one
of these other states.

175
00:09:26,000 --> 00:09:28,900
And another way to visualize
this is with a simulation.

176
00:09:28,900 --> 00:09:30,500
So a friend of mine did the simulation

177
00:09:30,500 --> 00:09:33,800
where he took these two
inverters in a feedback loop.

178
00:09:33,800 --> 00:09:36,000
And then this is the current.

179
00:09:36,000 --> 00:09:39,500
It takes to force it from
a zero to one state.

180
00:09:39,500 --> 00:09:43,400
So if we square that, we get the power.

181
00:09:43,400 --> 00:09:45,600
And you can see we have to do this work.

182
00:09:45,600 --> 00:09:48,100
We have to put work in to go up the hill.

183
00:09:48,100 --> 00:09:50,200
And then when we're
balanced on the top of the hill,

184
00:09:50,200 --> 00:09:51,700
we just stay there.

185
00:09:51,700 --> 00:09:55,100
And then the ball can stay there
for some long amount of time,

186
00:09:55,100 --> 00:09:56,500
longish amount of time

187
00:09:56,500 --> 00:09:58,400
until something knocks us off.

188
00:09:58,400 --> 00:10:01,000
And then we plot back
into the other state.

189
00:10:01,000 --> 00:10:03,400
So depending on where we start here,

190
00:10:03,400 --> 00:10:06,400
if we start here, we're going
to fall down fairly quickly

191
00:10:06,400 --> 00:10:07,500
back to one state.

192
00:10:07,500 --> 00:10:10,400
If we start here, we're going
to fall down to the other state.

193
00:10:10,400 --> 00:10:13,900
But if we start up here, it takes a
longer time to fall down.

194
00:10:13,900 --> 00:10:15,300
And if we start right in the middle,

195
00:10:15,300 --> 00:10:17,700
it can take a really long time.

196
00:10:17,700 --> 00:10:21,300
And when I say a long
time, I mean picoseconds.

197
00:10:21,300 --> 00:10:25,700
So now to get a bit of a feel of
what these lengths of times are

198
00:10:25,700 --> 00:10:27,300
and what the waveforms look like

199
00:10:27,300 --> 00:10:29,300
and have a bit of an interactive play,

200
00:10:29,300 --> 00:10:31,800
I developed this tool
that lets me scrub through

201
00:10:31,800 --> 00:10:33,700
a whole bunch of simulations.

202
00:10:33,700 --> 00:10:36,800
So I'm using Ngspice to run a loop

203
00:10:36,800 --> 00:10:41,700
as the D pulse gets moved
closer and closer to the clock

204
00:10:41,700 --> 00:10:43,900
and then through the clock
and then out of the clock.

205
00:10:43,900 --> 00:10:46,400
And then we can turn
on and off all the signals

206
00:10:46,400 --> 00:10:49,000
and have a look at how
they interact with each other.

207
00:10:49,000 --> 00:10:52,200
So if you want to follow
along, you can clone the repo,

208
00:10:52,200 --> 00:10:56,100
unzip the demo data set
that I have included in that

209
00:10:56,100 --> 00:10:57,500
and then run the GUI.

210
00:10:57,500 --> 00:10:59,400
If you've got the PDK installed locally,

211
00:10:59,400 --> 00:11:00,600
you can just run the simulation

212
00:11:00,600 --> 00:11:02,400
and then you can also tweak the SPICE deck

213
00:11:02,400 --> 00:11:04,200
and get different results.

214
00:11:04,200 --> 00:11:06,900
So when you start up the
program, it's going to look like this.

215
00:11:06,900 --> 00:11:11,400
We can move the data pulse
through into the sampling window

216
00:11:11,400 --> 00:11:14,500
and see how the output
changes from a low to a high.

217
00:11:14,500 --> 00:11:15,800
And then as we keep moving,

218
00:11:15,800 --> 00:11:19,000
it samples low again,
the output goes low.

219
00:11:19,000 --> 00:11:22,300
And we've got the schematic down here

220
00:11:22,300 --> 00:11:25,100
and we can turn on and
off these different waves

221
00:11:25,100 --> 00:11:26,800
to get a better understanding.

222
00:11:26,800 --> 00:11:31,100
So for example, we could look
at how the clock gets inverted

223
00:11:31,100 --> 00:11:34,700
and double-inverted
and we can move in here

224
00:11:34,700 --> 00:11:39,400
and we can use these
bars to measure the time.

225
00:11:39,400 --> 00:11:40,900
So let's just do that quickly.

226
00:11:40,900 --> 00:11:46,800
We're going to measure
from the 50% point,

227
00:11:46,800 --> 00:11:47,900
to the 50% point.

228
00:11:47,900 --> 00:11:51,500
So that's two inverters and
that's about 70 piece per second.

229
00:11:51,500 --> 00:11:57,000
So it's taken about 35 picoseconds
to go through each inverter.

230
00:11:57,000 --> 00:12:00,900
And that's the time between
the non-inverted clock

231
00:12:00,900 --> 00:12:04,400
and then going re-inverted
and then uninverted again.

232
00:12:04,400 --> 00:12:06,400
Now let's zoom in on that region

233
00:12:06,400 --> 00:12:08,500
where the signal has to stay still

234
00:12:08,500 --> 00:12:10,300
and see what happens
if it doesn't stay still.

235
00:12:10,300 --> 00:12:11,900
See what happens to the output.

236
00:12:11,900 --> 00:12:15,300
As that signal starts changing

237
00:12:15,300 --> 00:12:18,900
within the setup and hold
window, the aperture of the flip-flop,

238
00:12:18,900 --> 00:12:22,200
the output is taking
longer and longer to settle.

239
00:12:22,200 --> 00:12:26,700
So what we could do is turn on a
couple of these other waveforms

240
00:12:26,700 --> 00:12:29,700
and get a bit of a closer glimpse inside

241
00:12:29,700 --> 00:12:31,500
and turn off that inverted clock.

242
00:12:31,500 --> 00:12:38,600
And you can see how it takes
so much longer to settle down

243
00:12:38,600 --> 00:12:41,600
than it does when we're
outside a sampling window.

244
00:12:41,600 --> 00:12:45,400
And now maybe it's a good time to say

245
00:12:45,400 --> 00:12:48,900
that this is one simulation
from the typical, typical corner

246
00:12:48,900 --> 00:12:51,600
which means it's maybe
in the middle of the die

247
00:12:51,600 --> 00:12:53,900
where everything is
working fairly correctly.

248
00:12:53,900 --> 00:12:55,500
But you get these different corners,

249
00:12:55,500 --> 00:12:56,900
these different types of simulations

250
00:12:56,900 --> 00:13:01,200
for lower voltage, higher voltage,
faster MOSFETs, slower MOSFETs.

251
00:13:01,200 --> 00:13:03,700
And so if you want to know
the worst case of something,

252
00:13:03,700 --> 00:13:05,600
you've got to make sure that
you're using the right corner

253
00:13:05,600 --> 00:13:06,600
to simulate.

254
00:13:06,600 --> 00:13:09,200
And all that data gets
dumped into a Liberty file

255
00:13:09,200 --> 00:13:11,100
and that file is what's actually used

256
00:13:11,100 --> 00:13:13,100
to do the static timing analysis

257
00:13:13,100 --> 00:13:15,000
that you would use to
check that your design

258
00:13:15,000 --> 00:13:17,300
was actually going to
work and satisfy timing.

259
00:13:17,300 --> 00:13:19,700
You may be familiar
with this timing diagram,

260
00:13:19,700 --> 00:13:24,100
typical for a flip-flop where
we've got the clock with sampling.

261
00:13:24,100 --> 00:13:27,800
We've got to keep the data
steady in the set of and hold times

262
00:13:27,800 --> 00:13:30,300
and then we've got
some time for the output

263
00:13:30,300 --> 00:13:32,300
to settle into the new value.

264
00:13:32,300 --> 00:13:36,300
So let's measure what these
values are using the tool.

265
00:13:36,300 --> 00:13:39,000
And we'll start off with TCQ,
the time between the clock

266
00:13:39,000 --> 00:13:40,000
and the Q.

267
00:13:40,000 --> 00:13:43,600
Let me turn off these signals.

268
00:13:43,600 --> 00:13:48,100
So here we've got the clock.

269
00:13:48,100 --> 00:13:49,000
Here we've got the Q.

270
00:13:49,000 --> 00:13:52,900
So let's make sure
that's nice and stable.

271
00:13:52,900 --> 00:13:53,400
Put that there.

272
00:13:53,400 --> 00:13:59,000
And what I'm doing is I'm moving
the markers to their 50% point.

273
00:13:59,000 --> 00:14:01,100
That's 0.9 volts.

274
00:14:01,100 --> 00:14:04,300
And we're measuring 170 pico seconds.

275
00:14:04,300 --> 00:14:05,600
I've got to lose the wrong way around.

276
00:14:13,450 --> 00:14:15,375
So that's TCQ.

277
00:14:15,400 --> 00:14:17,800
Now how do we measure this setup time?

278
00:14:17,800 --> 00:14:21,000
So we do this by saying that we take TCQ

279
00:14:21,000 --> 00:14:23,900
and we say 5% more
of that time is acceptable.

280
00:14:23,900 --> 00:14:26,100
So about 180 picoseconds.

281
00:14:26,100 --> 00:14:31,300
And then we find the point
where D is to make the TCQ extend

282
00:14:31,300 --> 00:14:34,100
that much longer and
we call that the setup time.

283
00:14:34,100 --> 00:14:35,300
So let's measure it.

284
00:14:35,300 --> 00:14:40,600
So first I'll move this to
180 picoseconds down here.

285
00:14:40,600 --> 00:14:46,600
And then I'll move D in
until I get to that point.

286
00:14:46,600 --> 00:14:50,900
Zoom in a little bit maybe.

287
00:14:50,900 --> 00:14:54,000
About there.

288
00:14:54,000 --> 00:14:57,500
And then what I'll do is
I'll measure this distance

289
00:14:57,500 --> 00:14:59,400
between these two here.

290
00:14:59,400 --> 00:15:02,900
So I'll move this one here.

291
00:15:02,900 --> 00:15:05,700
And this one there.

292
00:15:05,700 --> 00:15:07,100
50% point.

293
00:15:07,100 --> 00:15:09,800
And I've got about 67 picoseconds.

294
00:15:09,800 --> 00:15:11,100
So that's our setup.

295
00:15:11,100 --> 00:15:12,600
About 70 picoseconds.

296
00:15:12,600 --> 00:15:14,700
Now let's measure the hold.

297
00:15:14,700 --> 00:15:20,000
And what I can do is we
need to see this edge changing.

298
00:15:20,000 --> 00:15:23,300
So I can bring back through
the other side of the waveform

299
00:15:23,300 --> 00:15:28,500
so that the output starts going low.

300
00:15:28,500 --> 00:15:29,300
Do the same thing.

301
00:15:29,300 --> 00:15:32,900
Move this to there we go.

302
00:15:32,900 --> 00:15:34,800
170.

303
00:15:34,800 --> 00:15:39,900
And then move it to 180 picoseconds.

304
00:15:39,900 --> 00:15:45,700
And then find the time of the data where
I'm on that.

305
00:15:45,700 --> 00:15:47,500
50% mark again.

306
00:15:51,467 --> 00:15:54,867
About there.

307
00:15:56,700 --> 00:16:01,421
And then again I'm going to
move this to the 50% point.

308
00:16:09,700 --> 00:16:13,300
And we're measuring about 20 picoseconds.

309
00:16:13,300 --> 00:16:16,400
But what do you notice
different about this waveform

310
00:16:16,400 --> 00:16:19,500
that we're seeing here
compared to the one

311
00:16:19,500 --> 00:16:22,000
that I showed you before?

312
00:16:22,000 --> 00:16:25,600
Here the hold is positive
and extends this way.

313
00:16:25,600 --> 00:16:29,100
But because the hold
window is now before the clock

314
00:16:29,100 --> 00:16:33,300
we call this a negative hold.

315
00:16:33,300 --> 00:16:38,400
And so really it would be better if
I had these the other way around.

316
00:16:38,400 --> 00:16:41,300
So if it was after if it was over here

317
00:16:41,300 --> 00:16:42,500
I would have a positive number.

318
00:16:42,500 --> 00:16:45,700
But because it's behind
in front of the clock

319
00:16:45,700 --> 00:16:48,500
I've got minus 20 picoseconds.

320
00:16:48,500 --> 00:16:52,000
So it's set up is the time that
the signal has to be steady

321
00:16:52,000 --> 00:16:53,900
in front of the clock signal.

322
00:16:53,900 --> 00:16:57,600
And hold is the time the signal has to
be steady after the clock signal.

323
00:16:57,600 --> 00:17:00,100
And as you've just seen with the sky 130
flip-flop

324
00:17:00,100 --> 00:17:02,800
the hold time can be negative and that
means the whole aperture

325
00:17:02,800 --> 00:17:05,100
is shifted in front of the clock.

326
00:17:05,100 --> 00:17:08,900
So we can move that aperture backwards
by delaying the clock

327
00:17:08,900 --> 00:17:10,000
with respect to the data.

328
00:17:10,000 --> 00:17:14,900
And we can do that by tweaking the sizes
of the MOSFETs in use

329
00:17:14,900 --> 00:17:17,000
while we're building the flip-flop.

330
00:17:17,000 --> 00:17:20,400
But this window the aperture stays a
constant width.

331
00:17:20,400 --> 00:17:25,200
So as we move it backwards we have the
effect of increasing the setup time.

332
00:17:25,200 --> 00:17:29,700
So we have less time to do the work for
the digital logic.

333
00:17:29,700 --> 00:17:33,800
So now let's see how setup and hold
impacts us as digital designers.

334
00:17:33,800 --> 00:17:35,900
One of the important questions we want
to know is

335
00:17:35,900 --> 00:17:39,000
how much time can we spend doing useful
computation

336
00:17:39,000 --> 00:17:42,200
and how much time do we lose by having
to keep the data steady

337
00:17:42,200 --> 00:17:44,700
during the setup and hold period.

338
00:17:44,700 --> 00:17:47,800
So for setup we can say we have this
worst case condition

339
00:17:47,800 --> 00:17:50,200
where we've got data coming out of one
flip-flop

340
00:17:50,200 --> 00:17:52,600
through some combinatorial logic that
takes some time

341
00:17:52,600 --> 00:17:54,300
and into a second flip-flop.

342
00:17:54,300 --> 00:17:56,300
And here we've got a rising clock edge.

343
00:17:56,300 --> 00:18:00,400
We've got Tcq the time it takes for
the data to come out of the flip-flop.

344
00:18:00,400 --> 00:18:03,000
The amount of time it takes the logic to
do its work.

345
00:18:03,000 --> 00:18:07,200
And then that data has got to be steady
and not moving the setup window.

346
00:18:07,200 --> 00:18:08,900
And this amount of time here is the
slack.

347
00:18:08,900 --> 00:18:12,500
The time we have left over to do extra
work.

348
00:18:12,500 --> 00:18:14,800
So we can write that out as an equation.

349
00:18:14,800 --> 00:18:17,800
 The clock period always got to be more
than Tcq

350
00:18:17,800 --> 00:18:21,100
plus the logic delay plus the setup time.

351
00:18:21,100 --> 00:18:23,300
And an interesting thing to notice about
this equation

352
00:18:23,300 --> 00:18:25,700
is that it involves the clock period.

353
00:18:25,700 --> 00:18:30,100
So it's say we did have a problem with
the data changing in the setup time.

354
00:18:30,100 --> 00:18:32,800
We could fix that just by increasing the
clock period

355
00:18:32,800 --> 00:18:34,300
by decreasing the frequency

356
00:18:34,300 --> 00:18:37,500
and that would bring that changing data
out of the setup time

357
00:18:37,500 --> 00:18:38,900
and then our problem would go away.

358
00:18:38,900 --> 00:18:41,200
We wouldn't get net stability anymore.

359
00:18:41,200 --> 00:18:44,200
Another important question is how
quickly can the data start changing

360
00:18:44,200 --> 00:18:47,800
after we get the clock and that's
related to the whole time.

361
00:18:47,800 --> 00:18:49,900
So if we take our worst case this time

362
00:18:49,900 --> 00:18:52,100
we've got the data coming into a
flip-flop

363
00:18:52,100 --> 00:18:54,500
and then immediately out into the next
flip-flop

364
00:18:54,500 --> 00:18:57,700
maybe for example in a shift register.

365
00:18:57,700 --> 00:18:59,500
And we want to know if we're going to
get a problem

366
00:18:59,500 --> 00:19:03,600
with the data changing within the whole
time of the second flip-flop.

367
00:19:03,600 --> 00:19:05,800
So we've seen this Tcq

368
00:19:05,800 --> 00:19:09,100
and if this is happening within the
whole window

369
00:19:09,100 --> 00:19:11,800
then we're going to get a metastability
problem.

370
00:19:11,800 --> 00:19:13,600
So the equation here is quite simple.

371
00:19:13,600 --> 00:19:16,700
Tcq has always got to be bigger than
hold.

372
00:19:16,700 --> 00:19:20,300
And it's interesting to note here that the
clock period is not part of this equation.

373
00:19:20,300 --> 00:19:23,600
Tcq and the hold time are both
parameters of a flip-flop

374
00:19:23,600 --> 00:19:25,400
and can't be changed later.

375
00:19:25,400 --> 00:19:28,800
So that's why hold time violations are
so scary

376
00:19:28,800 --> 00:19:31,700
because we can't fix them after a
takeout.

377
00:19:31,700 --> 00:19:35,200
And that's one reason why flip-flops
have this negative hold

378
00:19:35,200 --> 00:19:38,000
because it means that that equation can
never be true

379
00:19:38,000 --> 00:19:39,900
and we'll never get hold violations.

380
00:19:39,900 --> 00:19:41,900
So it's true that we lose time

381
00:19:41,900 --> 00:19:45,100
because we remember the aperture is
staying the same size

382
00:19:45,100 --> 00:19:46,500
we're just shifting it forwards.

383
00:19:46,500 --> 00:19:49,400
So we lose time that we can be using for
computation.

384
00:19:49,400 --> 00:19:51,500
It's as if we've got the bigger setup
time.

385
00:19:51,500 --> 00:19:55,000
But because we really want to avoid the
possibility of hold violations

386
00:19:55,000 --> 00:19:58,800
we're willing to sacrifice that extra
time.

387
00:19:58,800 --> 00:20:03,200
So given that the Sky130 D-Type flop has
a negative hold time

388
00:20:03,200 --> 00:20:07,400
how is it possible that MPW1 failed with
hold violations?

389
00:20:07,400 --> 00:20:10,300
So to give you time to think I'm going
to play this awesome render

390
00:20:10,300 --> 00:20:13,800
of a flip-flop doing its work done by
 Maximo Balestrini

391
00:20:34,400 --> 00:20:39,400
Well you probably saw my MPW1 fail vid so
you already know the answer to this question

392
00:20:39,400 --> 00:20:42,200
but the answer is it's to do with clock
skew.

393
00:20:42,200 --> 00:20:46,600
So before we were assuming that both
flip-flops had exactly the same clock

394
00:20:46,600 --> 00:20:51,600
but if we have two different clocks then
basically all our plans go out the window

395
00:20:51,600 --> 00:20:55,800
and we can end up with data changing
within either the setup or the hold time.

396
00:20:55,800 --> 00:21:00,700
And the problem with MPW1 was that the
clock tree was synthesized badly

397
00:21:00,700 --> 00:21:05,400
and we had so much skew across the chip
that we ended up with hold violations.

398
00:21:05,400 --> 00:21:10,200
So to summarize the Sky130 flop is a
transmission gate flip flop

399
00:21:10,200 --> 00:21:15,200
which according to the Berkeley paper is a
good compromise on power and race immunity

400
00:21:15,200 --> 00:21:18,700
and it's got some nice graphs in the
rest of the paper.

401
00:21:18,700 --> 00:21:21,800
You can have a look at if you want to
understand even deeper.

402
00:21:21,800 --> 00:21:25,700
So I'd like to say again thanks to the
Zero-To-ASIC Course Community

403
00:21:25,700 --> 00:21:28,900
to the anonymous ASIC Engineer who
helped to review the slides

404
00:21:28,900 --> 00:21:31,100
and come up with the idea in the first
place.

405
00:21:31,100 --> 00:21:34,600
Stefan Schippers for some input on Spice
modeling.

406
00:21:34,600 --> 00:21:40,300
And for resources, Colin O'Flynn's
Metasibility demo on an FPGA is pretty good.

407
00:21:40,300 --> 00:21:46,100
Shawn Hymel just got an FPGA series out with
DigiKey and the latest one talks about Metastability.

408
00:21:46,100 --> 00:21:50,300
And of course you can get lots more information
and learn how to design chips yourself

409
00:21:50,300 --> 00:21:52,300
on the Zero-To-ASIC Course.

410
00:21:52,300 --> 00:21:55,300
So thanks for watching the video and
stay tuned for the next one.

411
00:21:55,500 --> 00:22:06,500
[Music]

412
00:22:06,500 --> 00:22:12,460
[BLANK_AUDIO]

